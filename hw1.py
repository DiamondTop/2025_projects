# -*- coding: utf-8 -*-
"""HW1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iDJ8Wi-3ZtPDjijiBnFk2p4qcQdmyfOh

#21
"""

x = 10
def myfunc(x):

  x +=5
  print(x)

myfunc(x)

"""# X does not have a value outside of the function, so outting the variable declaration inside the function.

#22.	Write a function safe_divide(a, b) that divides two numbers but returns "Error: Division by zero" if b=0.
"""

def safe_divide(a,b):
  if b == 0:
    return "Error: Division by zero"
    print("Error: Divison by zero")
  else:
    divide = a/b
    return divide

safe_divide(3,1)

"""# 23.	Create a list of all squares from 1 to 20 that are divisible by 3."""

squares_div_by_3 = []
for i in range(1,21):
  square = i ** 2 # the variable is raised to the power of 2
  if square % 3 == 0: # number divide by 3 remainder is 0
    squares_div_by_3.append(square)
print(squares_div_by_3)

"""#Example 24. Write a function that takes a list of numbers, specifically [1, 2, 3, …, 1000] and returns a dictionary with keys "even" and "odd", mapping to lists of even and odd numbers."""

def even_odd(list):
  # loop to add even and odd numbers to the list
  even_list = []
  odd_list = []

  for numbers in list:
    if numbers % 2 == 0:
      even_list.append(numbers)
    else:
      odd_list.append(numbers)

  return {"Even Numbers list": even_list, "Odd Numbers list": odd_list}

range_list = list(range(1,1001)) # Creates a list from 1 to 1000
result_list = even_odd(range_list)
print(result_list)

"""# 25.	Given sentence = "data science is fun", write a program that counts the frequency of each word and stores it in a dictionary."""

sentence = 'data science data is fun'

# Create an empty dictionary to store the word frequencies
word_counts = {}

# Split the sentence into a list of words
words = sentence.split()

for word in words:
  if word in word_counts:
    word_counts[word] += 1

  else:
    word_counts[word] = 1

print(word_counts) # showing the dictionary results

"""# 26.	Given the tuple (1, 3, 4, 2, 3, 5, 6, 3, 0, 3, 4)
1)	Remove the LAST occurrence of the value 3.
2)	Remove the SECOND-TO-LAST of the value 3.

"""

tuple_list = [1,3,4,2,3,5,6,3,0,3,4]
target_numnber = 3

occurrences = 0
positions = []

for index, element in enumerate(tuple_list):
    if element == target_numnber:
        #print(element)#checking to print target number
        occurrences += 1
        positions.append(index)

print(f"'{target_numnber}' appears {occurrences} time(s) in the list.")
print(f"Positions: {positions}")

tuple_list.pop(9) # remove position 9 - last position
tuple_list.pop(7) # remove position 7 - 2nd last position
print(tuple_list)

"""27.	Given two dictionaries:

Write Python code to merge them so that overlapping keys sum their values  Result should be {"a": 1, "b": 5, "c": 4}.
dict1 = {"a": 1, "b: 2}
dict2 = {"b": 3, "c": 4}

"""

dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}

merged_dict = dict1 | dict2
print(merged_dict)

dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}

for key, value in dict2.items():
    dict1[key] = dict1.get(key, 0) + value

print(dict1)

"""28.	Write a Python function clean_split(sentence) that:
•	Splits a given sentence into individual words.
•	Removes leading/trailing spaces and punctuation , . ! ? ; : from each word.
•	Returns a list of cleaned words.
Example:
sentence = "  Wow!How is that possible?  This is unbelievable;MJ, rocks!! "
clean_split(sentence)
Expected Output:
['Wow', 'How', 'is', 'that', 'possible', 'This', 'is', 'unbelievable', 'MJ', 'rocks']
"""

def clean_split(sentence):

  # Define the punctuation characters to remove
  new_string = sentence.replace("!", " ")
  new_string = new_string.replace(";", " ")
  new_string = new_string.replace("?", " ")


  #print(new_string)
  # Split the sentence by whitespace
  words = new_string.split()
  #print(words)

  return words

sentence = " Wow!How is that possible? This is unbelievable;MJ, rocks!! "


cleaned_words_list = clean_split(sentence)
print(cleaned_words_list)

"""29.	Class Inheritance in a Finance Context
1)	Create a base class Account with:
•	An __init__ method that takes account_holder and balance and stores them.
•	A method display_balance() that returns "<account_holder> has a balance of $<balance>".
•	A __str__ method that returns "Account: <account_holder>, Balance: $<balance>".
2)	Create two subclasses, SavingsAccount and CheckingAccount, that inherit from Account:
•	Override the display_balance() method in each subclass:
-	SavingsAccount: "<account_holder> has $<balance> in savings.
-	CheckingAccount: "<account_holder> has $<balance> in checking.
•	Add a new method unique to each subclass:
-	SavingsAccount: add_interest(rate) returns "<account_holder> earned $<interest> in interest.
-	CheckingAccount: deduct_fee(fee) returns "$<fee> deducted from <account_holder>'s account."
•	Override the __str__ method to reflect the account type:
-	SavingsAccount: "Savings Account: <account_holder>, Balance: $<balance>"
-	CheckingAccount: "Checking Account: <account_holder>, Balance: $<balance>"

"""

class Account:
  def __init__(self, account_holder, initial_balance=0.0):
    self.account_holder = account_holder
    self.balance = initial_balance

  def display_balance(self):
    return f"{self.account_holder} has a balance of ${self.balance:.2f}."

  def __str__(self):
        """String representation of the generic account."""
        return f"Account: {self.account_holder}, Balance: ${self.balance:.2f}"

#sub class
class SavingsAccount(Account):

    def __init__(self, account_holder, balance):
        # Call the parent's __init__ method to set up account_holder and balance
        super().__init__(account_holder, balance)

    def display_balance(self):
        """Overrides the parent method to show a savings balance."""
        return f"{self.account_holder} has ${self.balance:.2f} in savings Account."

    def add_interest(self, rate):
        interest = self.balance * rate
        self.balance += interest
        return f"{self.account_holder} earned ${interest:.2f} in interest."

    def __str__(self):
        ###OVerrides the parent's string method for savings account
        return f"Savings Account: {self.account_holder}, Balance: ${self.balance:.2f}"

class CheckingAccount(Account):

  """A checking account subclass."""
  def __init__(self, account_holder, balance):
        # Call the parent's __init__ method
        super().__init__(account_holder, balance)

  def display_balance(self):
        """Overrides the parent method to show a checking balance."""
        print(f"{self.account_holder} has ${self.balance} in checking.")

  def deduct_fee(self, fee):
        self.balance -= fee
        return f"${fee:.2f} deducted from {self.account_holder}'s account."
        ###OVerrides the parent's class string method for savings account
  def __str__(self):
        return f"Checking Account: {self.account_holder}, Balance: ${self.balance:.2f}"

"""3)	Create objects for each class and call their display_balance() method, the new subclass-specific method, and print() to show their string representation."""

# Create an instance
account = Account("Alice", 1000)
savings_account = SavingsAccount("Bob", 2000)
checking_account = CheckingAccount("Charlie", 1500)

print(account)
print(savings_account)
print(checking_account)

print(account.display_balance())
print(savings_account.display_balance())
print(savings_account.add_interest(0.05))
print(checking_account.display_balance())
print(checking_account.deduct_fee(50))